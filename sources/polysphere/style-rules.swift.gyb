extension UI.Style 
{
    struct FontSelection:Hashable, CustomStringConvertible
    {
        let fontfile:String, 
            size:Int 
        
        var description:String 
        {
            return "'\(self.fontfile)'@\(self.size)"
        }
    }
    
    enum Feature:Equatable
    {
        %{
        features = (
            ('kern', 'Bool'), 
            ('calt', 'Bool'), 
            ('liga', 'Bool'), 
            ('hlig', 'Bool'), 
            ('case', 'Bool'), 
            ('cpsp', 'Bool'), 
            ('smcp', 'Bool'), 
            ('pcap', 'Bool'), 
            ('c2sc', 'Bool'), 
            ('c2pc', 'Bool'), 
            ('unic', 'Bool'), 
            ('ordn', 'Bool'), 
            ('zero', 'Bool'), 
            ('frac', 'Bool'), 
            ('afrc', 'Bool'), 
            ('sinf', 'Bool'), 
            ('subs', 'Bool'), 
            ('sups', 'Bool'), 
            ('ital', 'Bool'), 
            ('mgrk', 'Bool'), 
            ('lnum', 'Bool'), 
            ('onum', 'Bool'), 
            ('pnum', 'Bool'), 
            ('tnum', 'Bool'), 
            ('rand', 'Bool'), 
            ('salt', 'Int'), 
            ('swsh', 'Int'), 
            ('titl', 'Bool')
        )
        }%
        
        % for name, T in features:
            case `${name}`(${T})
        % end
        
        var value:Int 
        {
            switch self 
            {
            case ${', '.join('.`{0}`(let on)'.format(name) for name, T in features if T == 'Bool')}:
                return on ? 1 : 0
            
            case ${', '.join('.`{0}`(let value)'.format(name) for name, T in features if T == 'Int')}:
                return value
            }
        }
        
        var tag:UInt32
        {
            let characters:(UInt8, UInt8, UInt8, UInt8)
            switch self 
            {
            % for name, T in features:
            case .`${name}`:
                characters = (${', '.join(map(str, map(ord, name)))})
            % end 
            }
            
            return  .init(characters.0) << 24 | 
                    .init(characters.1) << 16 | 
                    .init(characters.2) << 8  | 
                    .init(characters.3)
        }
        
        init?(string:String, value:Int) 
        {
            switch string 
            {
            % for name, T in features:
            case ${'"{0}"'.format(name)}:
                % if T == 'Bool':
                self = .${name}(value == 0 ? false : true)
                % elif T == 'Int':
                self = .${name}(value)
                % end 
            % end
            
            default:
                return nil 
            }
        }
    }
    
    struct Metrics 
    {
        var top:Int, 
            right:Int, 
            bottom:Int, 
            left:Int 
        
        static 
        let zero:Self = .init(0)
        
        init(top:Int, right:Int, bottom:Int, left:Int) 
        {
            self.top    = top 
            self.right  = right 
            self.bottom = bottom 
            self.left   = left
        }
        
        init(top:Int, horizontal:Int, bottom:Int) 
        {
            self.init(top: top, right: horizontal, bottom: bottom, left: horizontal)
        }
        
        init(vertical:Int, horizontal:Int) 
        {
            self.init(top: vertical, right: horizontal, bottom: vertical, left: horizontal)
        }
        
        init(_ width:Int) 
        {
            self.init(top: width, right: width, bottom: width, left: width)
        }
    }
    
    enum Positioning:Sheet.Enumeration
    {
        case relative, absolute 
        
        static 
        var type:Sheet.Parse.Expression.Keyword 
        {
            .positioning
        }
        
        init?(string:String) 
        {
            switch string 
            {
            case "relative":
                self = .relative 
            case "absolute":
                self = .absolute
            default:
                return nil 
            }
        }
    }
    
    enum Alignment:Sheet.Enumeration
    {
        case begin, middle, end, justify
        
        static 
        var type:Sheet.Parse.Expression.Keyword 
        {
            .alignment
        }
        
        init?(string:String) 
        {
            switch string 
            {
            case "begin":
                self = .begin 
            case "middle":
                self = .middle
            case "end":
                self = .end 
            case "justify":
                self = .justify
            default:
                return nil 
            }
        }
    }
    
    %{
    inline_properties = (
        ('color',           'Vector4<UInt8>',   '.init(repeating: .max)'), 
        ('font',            'FontSelection',    '.init(fontfile: "assets/fonts/SourceSansPro-Regular.ttf", size: 16)'),
        ('features',        '[Feature]',        '[.kern(true)]')
    )
    
    block_properties = (
        ('wrap',            'Bool',                 'true'), 
        ('indent',          'Int',                  '0'), 
        ('lineheight',      'Int',                  '0'), 
        ('position2',       'Vector2<Int>',         '.init(0, 0)'), 
        ('position3',       'Vector3<Float>',       '.init(.nan, .nan, .nan)'), 
        ('padding',         '(Int, Int, Int, Int)', '(0, 0, 0, 0)'), 
        ('positioning',     'Positioning',          '.relative'),
        ('align',           'Alignment',            '.begin')
    )
    }%
    
    %{
    properties = (
        ('color',           'text color',           'Vector4<Float>',   '.init(1, 1, 1, 1)'), 
        ('trace',           '3D tracing center',    'Vector3<Float>',   '.init(.nan, .nan, .nan)'), 
        ('offset',          '2D offset',            'Vector2<Float>',   '.init(0, 0)'), 
        ('padding',         'padding metrics',      'Metrics',          '.zero'), 
        ('indent',          'indentation',          'Int',              '0'), 
        ('line_height',     'line-height',          'Int',              '0'), 
        ('wrap',            'line-wrapping mode',   'Bool',             'true'), 
        ('font',            'font selection',       'FontSelection',    '.init(fontfile: "assets/fonts/SourceSansPro-Regular.ttf", size: 16)'),
        ('features',        'font feature list',    '[Feature]',        '[.kern(true)]'), 
        ('position',        'positioning mode',     'Positioning',      '.relative'),
        ('align',           'alignment mode',       'Alignment',        '.begin')
    )
    }%
    enum Property 
    {
        % for property, prose, type, default in properties:
        case ${property}
        % end
        
        init?(_ string:String) 
        {
            switch string 
            {
            % for property, prose, type, default in properties:
            case ${'"{0}"'.format(property)}:
                self = .${property}
            % end
            default:
                return nil 
            }
        }
        
        var prosaicDescription:String 
        {
            switch self 
            {
            % for property, prose, type, default in properties:
            case .${property}:
                return ${'"{0}"'.format(prose)}
            % end
            }
        }
    }
    struct _Rules 
    {
        private 
        var properties:[Property: Any] = [:]
        
        % for property, prose, type, default in properties:
        var ${property}:${type} 
        {
            get 
            {
                self.properties[.${property}] as? ${type} ?? ${default} 
            }
            set(${property})
            {
                self.properties[.${property}] = ${property}
            }
        }
        % end
        
        mutating 
        func overlay(with other:Self) 
        {
            self.properties.merge(other.properties)
            { 
                (_, new) in 
                new 
            }
        }
        func overlaid(with other:Self) -> Self
        {
            return .init(properties: self.properties.merging(other.properties)
            { 
                (_, new) in 
                new 
            })
        }
    }
    
    enum Rules 
    {
        % for T, properties in ('Inline', inline_properties), ('Block', block_properties):
        struct ${T}:CustomStringConvertible
        {
            % for property, property_type, default in properties:
            var ${property}:${property_type}?
            % end 
            
            init(${', '.join('{0}:{1}? = nil'.format(property, property_type) for property, property_type, default in properties)})
            {
                % for property, property_type, default in properties:
                self.${property} = ${property}
                % end 
            }
            
            var description:String 
            {
                let rules:[String?] = 
                [
                % for property, property_type, default in properties:
                    self.${property}.map{ ${'"    self.{0}: \($0)"'.format(property)} }, 
                % end 
                ]
                
                return "{\n\(rules.compactMap{ $0 }.joined(separator: "\n"))\n}"
            }
        }
        % end 
    }
    
    % for T, properties in ('Inline', inline_properties), ('Block', block_properties):
    struct ${T}:CustomStringConvertible
    {
        % for property, property_type, default in properties:
        var ${property}:${property_type} = ${default}
        % end 
        
        mutating 
        func update(with rules:Rules.${T}) 
        {
            % for property, property_type, default in properties:
            if let ${property}:${property_type} = rules.${property} 
            {
                self.${property} = ${property}
            }
            % end 
        }
         
        func updated(with rules:Rules.${T}) -> Self
        {
            var new:Self = self 
            new.update(with: rules)
            return new
        }
        
        var description:String 
        {
            return ${'"{{\\n{0}\\n}}"'.format('\\n'.join('    {0}: \(self.{0})'.format(property) for property, property_type, default in properties))}
        }
    }
    % end 
}
