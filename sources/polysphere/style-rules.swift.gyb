extension UI.Style 
{
    struct FontSelection:Hashable, CustomStringConvertible
    {
        let fontfile:String, 
            size:Int 
        
        var description:String 
        {
            return "'\(self.fontfile)'@\(self.size)"
        }
    }
    
    enum Feature:Equatable, CustomStringConvertible
    {
        %{
        features = (
            ('kern', 'Bool'), 
            ('calt', 'Bool'), 
            ('liga', 'Bool'), 
            ('hlig', 'Bool'), 
            ('case', 'Bool'), 
            ('cpsp', 'Bool'), 
            ('smcp', 'Bool'), 
            ('pcap', 'Bool'), 
            ('c2sc', 'Bool'), 
            ('c2pc', 'Bool'), 
            ('unic', 'Bool'), 
            ('ordn', 'Bool'), 
            ('zero', 'Bool'), 
            ('frac', 'Bool'), 
            ('afrc', 'Bool'), 
            ('sinf', 'Bool'), 
            ('subs', 'Bool'), 
            ('sups', 'Bool'), 
            ('ital', 'Bool'), 
            ('mgrk', 'Bool'), 
            ('lnum', 'Bool'), 
            ('onum', 'Bool'), 
            ('pnum', 'Bool'), 
            ('tnum', 'Bool'), 
            ('rand', 'Bool'), 
            ('salt', 'Int'), 
            ('swsh', 'Int'), 
            ('titl', 'Bool')
        )
        }%
        
        % for name, T in features:
            case `${name}`(${T})
        % end
        
        var value:Int 
        {
            switch self 
            {
            case ${', '.join('.`{0}`(let on)'.format(name) for name, T in features if T == 'Bool')}:
                return on ? 1 : 0
            
            case ${', '.join('.`{0}`(let value)'.format(name) for name, T in features if T == 'Int')}:
                return value
            }
        }
        
        var tag:UInt32
        {
            let characters:(UInt8, UInt8, UInt8, UInt8)
            switch self 
            {
            % for name, T in features:
            case .`${name}`:
                characters = (${', '.join(map(str, map(ord, name)))})
            % end 
            }
            
            return  .init(characters.0) << 24 | 
                    .init(characters.1) << 16 | 
                    .init(characters.2) << 8  | 
                    .init(characters.3)
        }
        
        init?(string:String, value:Int) 
        {
            switch string 
            {
            % for name, T in features:
            case ${'"{0}"'.format(name)}:
                % if T == 'Bool':
                self = .${name}(value == 0 ? false : true)
                % elif T == 'Int':
                self = .${name}(value)
                % end 
            % end
            
            default:
                return nil 
            }
        }
        
        var description:String 
        {
            switch self
            {
            % for name, T in features:
            case .${name}(let value):
                return ${'"{0}(\\(value))"'.format(name)}
            % end
            }
        }
    }
    
    struct Metrics 
    {
        var top:Int, 
            right:Int, 
            bottom:Int, 
            left:Int 
        
        static 
        let zero:Self = .init(0)
        
        init(top:Int, right:Int, bottom:Int, left:Int) 
        {
            self.top    = top 
            self.right  = right 
            self.bottom = bottom 
            self.left   = left
        }
        
        init(top:Int, horizontal:Int, bottom:Int) 
        {
            self.init(top: top, right: horizontal, bottom: bottom, left: horizontal)
        }
        
        init(vertical:Int, horizontal:Int) 
        {
            self.init(top: vertical, right: horizontal, bottom: vertical, left: horizontal)
        }
        
        init(_ width:Int) 
        {
            self.init(top: width, right: width, bottom: width, left: width)
        }
    }
    
    enum Positioning:Sheet.Enumeration
    {
        case relative, absolute 
        
        static 
        var type:Sheet.Parse.Expression.Keyword 
        {
            .positioning
        }
        
        init?(string:String) 
        {
            switch string 
            {
            case "relative":
                self = .relative 
            case "absolute":
                self = .absolute
            default:
                return nil 
            }
        }
    }
    
    enum Alignment:Sheet.Enumeration
    {
        case begin, middle, end, justify
        
        static 
        var type:Sheet.Parse.Expression.Keyword 
        {
            .alignment
        }
        
        init?(string:String) 
        {
            switch string 
            {
            case "begin":
                self = .begin 
            case "middle":
                self = .middle
            case "end":
                self = .end 
            case "justify":
                self = .justify
            default:
                return nil 
            }
        }
    }
    
    %{
    properties = (
        ('color',           'text color',           'Vector4<UInt8>',   '.init(0, 0, 0, .max)'), 
        ('trace',           '3D tracing center',    'Vector3<Float>',   '.init(.nan, .nan, .nan)'), 
        ('offset',          '2D offset',            'Vector2<Float>',   '.init(0, 0)'), 
        ('padding',         'padding metrics',      'Metrics',          '.zero'), 
        ('indent',          'indentation',          'Int',              '0'), 
        ('line_height',     'line-height',          'Int',              '0'), 
        ('wrap',            'line-wrapping mode',   'Bool',             'true'), 
        ('font',            'font selection',       'FontSelection',    '.init(fontfile: "assets/fonts/default", size: 16)'),
        ('features',        'font feature list',    '[Feature]',        '[.kern(true)]'), 
        ('position',        'positioning mode',     'Positioning',      '.relative'),
        ('align',           'alignment mode',       'Alignment',        '.begin')
    )
    }%
    enum Property 
    {
        % for property, prose, type, default in properties:
        case ${property}
        % end
        
        init?(_ string:String) 
        {
            switch string 
            {
            % for property, prose, type, default in properties:
            case ${'"{0}"'.format(property)}:
                self = .${property}
            % end
            default:
                return nil 
            }
        }
        
        var prosaicDescription:String 
        {
            switch self 
            {
            % for property, prose, type, default in properties:
            case .${property}:
                return ${'"{0}"'.format(prose)}
            % end
            }
        }
    }
    struct Rules:CustomStringConvertible
    {
        private 
        var properties:[Property: Any] = [:]
        
        % for property, prose, type, default in properties:
        var ${property}:${type} 
        {
            get 
            {
                self.properties[.${property}] as? ${type} ?? ${default} 
            }
            set(${property})
            {
                self.properties[.${property}] = ${property}
            }
        }
        mutating 
        func set(${property}:${type}?)
        {
            self.properties[.${property}] = ${property}
        }
        % end
        
        init() 
        {
            self.properties = [:]
        }
        
        init(_ properties:[Property: Any]) 
        {
            // check types 
            var checked:[Property: Any] = properties
            for (property, value):(Property, Any) in properties 
            {
                switch property 
                {
                % for property, prose, type, default in properties:
                case .${property}:
                    guard value is ${type} 
                    else 
                    {
                        Log.error("value of incorrect type '\(type(of: value))' evaded validation checks for initialization of property '\(property)' (expected \(${type}.self))")
                        checked[.${property}] = nil 
                        break 
                    }
                % end
                }
            }
            
            self.properties = properties
        }
        
        mutating 
        func overlay(with other:Self) 
        {
            self.properties.merge(other.properties)
            { 
                (_, new) in 
                new 
            }
        }
        func overlaid(with other:Self) -> Self
        {
            return .init(self.properties.merging(other.properties)
            { 
                (_, new) in 
                new 
            })
        }
        
        var description:String 
        {
            "{\n\(self.properties.map{ "    \($0.0): \($0.1)" }.joined(separator: "\n"))\n}"
        }
    }
}
