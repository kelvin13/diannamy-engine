protocol _UIElement 
{
    typealias Block = _UIElementBlock
    typealias SuperBlock = _UIElementSuperBlock
    var classes:Set<String> 
    {
        get 
    }
    var identifier:String? 
    {
        get 
    }
}
protocol _UIElementBlock:UI.Element, RandomAccessCollection where Element:UI.Element.Block
{
    var cache:Layout 
    {
        get 
        set 
    }
    var style:UI.Style.Rules 
    {
        get 
    }
    var recomputeStyle:Bool 
    {
        get 
    }
    
    func contribute(text:inout [UI.Text.DrawElement], offset:Vector2<Float>)
    func contribute(geometry:inout [UI.Geometry.DrawElement], offset:Vector2<Float>)
    
    // returns true if the event was captured in the given pass
    mutating 
    func event(_ event:UI.Event, pass:UI.Event.Pass)  
    
    // shifts focus in the given "direction", returns true if end is reached 
    // up and down should provide complete traversal, left and right can offer 
    // skips and shortcuts
    mutating 
    func navigate(_ direction:UI.Event.Direction.D2) -> Bool 
    
    // returns true if state changed (for example, updating an animation)
    mutating 
    func process(delta:Int, allotment:Vector2<Int>) -> Bool 
    
    mutating 
    func layoutBefore(definitions:inout UI.Styles, path:UI.Style.Path) 
    // returns the minimum size of leaf content, if any 
    mutating 
    func layoutLeaf() -> Vector2<Int>?
    // returns the actual size of leaf content, after hard layout has been computed
    mutating 
    func layoutLeafContent() -> Vector2<Int>
    
    mutating 
    func observe(style new:UI.Style.Rules)
    mutating 
    func observe(canvas new:Vector2<Int>)
}
extension UI.Element.Block
{
    var startIndex:Int 
    {
        0
    }
    var endIndex:Int 
    {
        0
    }
    subscript(index:Int) -> Never 
    {
        Log.unreachable()
    }
    
    func contribute(textOffset offset:Vector2<Float>) -> [UI.Text.DrawElement]
    {
        var elements:[UI.Text.DrawElement] = [] 
        self.contribute(text: &elements, offset: offset)
        return elements
    }
    func contribute(geometryOffset offset:Vector2<Float>) -> [UI.Geometry.DrawElement]
    {
        var elements:[UI.Geometry.DrawElement] = [] 
        self.contribute(geometry: &elements, offset: offset)
        return elements
    }
    
    func contribute(text _:inout [UI.Text.DrawElement], offset _:Vector2<Float>) 
    {
    }
    func contribute(geometry _:inout [UI.Geometry.DrawElement], offset _:Vector2<Float>)
    {
    }
    
    func event(_:UI.Event, pass _:UI.Event.Pass)  
    {
    }
    
    func navigate(_:UI.Event.Direction.D2) -> Bool 
    {
        return true 
    }
    
    func process(delta _:Int, allotment:Vector2<Int>) -> Bool 
    {
        return false 
    }
    
    func layoutBefore(definitions _:inout UI.Styles, path _:UI.Style.Path)  
    {
    }
    func layoutLeaf() -> Vector2<Int>? 
    {
        return nil 
    }
    func layoutLeafContent() -> Vector2<Int>
    {
        return .zero
    }
    func observe(style _:UI.Style.Rules) 
    {
    }
    func observe(canvas _:Vector2<Int>)
    {
    }
}
/* extension UI.Element.Block 
{
    enum Claim 
    {
        case fixed(width:Int)
        case claim(minWidth:Int, claims:Int)
    }
    
    /* struct Space:Equatable
    {
        //  |<- white.outer ->|<- gray ->|<- white.inner ->|<------ black ------>|<- gray ->|<- white.outer ->| 
        var white:(inner:Style.Metrics, outer:Style.Metrics), // space the margin can intrude on 
            gray:Style.Metrics, // space the border can intrude on 
            black:Vector2<Int> // space the padding and content are limited to
        
        mutating 
        func space(white:Style.Metrics)
        {
            func space(metricComponent metric:KeyPath<Metrics, Int>, areaComponent area:KeyPath<Vector2<Int>, Int>) 
            {
                if self.gray[keyPath: metric] > 0 
                {
                    self.black[keyPath: area]        -= 
                        max(0,        white[keyPath: metric]                                      - self.white.inner[keyPath: metric])
                    self.white.inner[keyPath: metric] = 
                        max(          white[keyPath: metric],                                       self.white.inner[keyPath: metric])
                }
                else 
                {
                    self.black[keyPath: area]        -= 
                        max(0, max(0, white[keyPath: metric] - self.white.outer[keyPath: metric]) - self.white.inner[keyPath: metric])
                    self.white.inner[keyPath: metric] = 
                        max(   max(0, white[keyPath: metric] - self.white.outer[keyPath: metric]),  self.white.inner[keyPath: metric])
                }
            }
            
            space(metricComponent: \.top,    areaComponent: \.y)
            space(metricComponent: \.right,  areaComponent: \.x)
            space(metricComponent: \.bottom, areaComponent: \.y)
            space(metricComponent: \.left,   areaComponent: \.x)
        }
        
        mutating 
        func space(gray:Style.Metrics)
        {
            func space(metricComponent metric:KeyPath<Metrics, Int>, areaComponent area:KeyPath<Vector2<Int>, Int>) 
            {
                if self.white.inner[keyPath: metric] > 0 
                {
                    self.black[keyPath: area]        -= gray[keyPath: metric] 
                    self.gray[keyPath: metric]        = gray[keyPath: metric]
                    self.white.outer[keyPath: metric] = self.white.inner[keyPath: metric]
                    self.white.inner[keyPath: metric] = 0 
                }
                else 
                {
                    self.black[keyPath: area]        -= max(0, gray[keyPath: metric]  - self.gray[keyPath: metric])
                    self.gray[keyPath: metric]        = max(   gray[keyPath: metric],  self.gray[keyPath: metric])
                }
            }
            
            space(metricComponent: \.top,    areaComponent: \.y)
            space(metricComponent: \.right,  areaComponent: \.x)
            space(metricComponent: \.bottom, areaComponent: \.y)
            space(metricComponent: \.left,   areaComponent: \.x)
        }
        
        mutating 
        func fillTop(black:Int, gray:Int, white:Int) 
        {
            self.fill(metricComponent: \.top, areaComponent: \.y, black: black, gray: gray, white: white)
        }
        mutating 
        func fillRight(black:Int, gray:Int, white:Int) 
        {
            self.fill(metricComponent: \.right, areaComponent: \.x, black: black, gray: gray, white: white)
        }
        mutating 
        func fillBottom(black:Int, gray:Int, white:Int) 
        {
            self.fill(metricComponent: \.bottom, areaComponent: \.y, black: black, gray: gray, white: white)
        }
        mutating 
        func fillLeft(black:Int, gray:Int, white:Int) 
        {
            self.fill(metricComponent: \.left, areaComponent: \.x, black: black, gray: gray, white: white)
        }
        private mutating 
        func fill(metricComponent metric:KeyPath<Metrics, Int>, areaComponent area:KeyPath<Vector2<Int>, Int>, black:Int, gray:Int, white:Int) 
        {
            self.black[keyPath: area]          -= black + white + gray
            self.white.inner[keyPath: metric]   = white 
            self.gray[keyPath: metric]          = gray  
            self.white.outer[keyPath: metric]   = 0 
        }
    }
    struct BoxModel 
    {
        enum Cache 
        {
            struct Content 
            {
            }
        }
        let sequence:UInt
    } */
    
    func block(styledefs:inout UI.Style, parentPath:UI.Style.Path) 
    {
        let path:Style.Path = parentPath.appended(self)
        // check block styles 
        let (sequence, style):(UInt, Style.Rules) = styledefs.resolve(path)
        if (self.sequence.map{ $0 != sequence }) ?? true 
        {
            self.cache.invalidate()
            self.sequence = sequence
        }
        
        let size:Vector2<Int> =  self.layout(style: style, path: path)
    }
    
    struct Cache 
    {
        enum Status 
        {
            enum Style 
            {
                enum Box 
                {
                    enum Content 
                    {
                        case invalid 
                        case valid
                    }
                    
                    case invalid
                    case valid(content:Content)
                }
                
                case invalid
                case valid(sequence:UInt, box:Box)
            }
        }
        
        var style:UI.Style.Rules,
            claim:Claim, 
            status:Status
    }
    
    mutating 
    func style(definitions:inout UI.Styles, ancestry:UI.Style.Path) 
    {
        let path:Style.Path                             = ancestry.appended(self)
        let lookup:(sequence:UInt, rules:Style.Rules)   = definitions.resolve(path)
        switch self.cache.status  
        {
        case .valid(sequence: let sequence, box: _):
            if lookup.sequence != sequence 
            {
                fallthrough
            }
        
        default:
            self.cache.computed = lookup.style.overlaid(with: self.style)
            self.cache.status   = .valid(sequence: lookup.sequence, box: .invalid)
        }
        
        for child:Int in 0 ..< self.count 
        {
            self[child].style(definitions: &definitions, ancestry: path)
        }
    }
    
    func claim() -> (x:Claim, y:Claim)
    {
        switch self.cache.status 
        {
        case .valid(sequence: _, box: .valid(content: _)):
            break 
        
        default:
            break
        }
        
        
        switch self.cache.computed.axis
        {
        case .horizontal:
            var claims:[Claim] = [self.claimNode().x]
            var before:Collapse = .black 
            
            break 
        case .vertical:
            break
        }
        
        var claims:[(x:Claim, y:Claim)] = [self.claimNode()]
        for child:Int in 0 ..< self.count 
        {
            if let block:UI.Element.Block = self[child] as? UI.Element.Block 
            {
                claims.append(block.claim())
            }
        }
    }
    
    func fill(style:UI.Style, path:UI.Style.Path, space:Space, claims:Int, claimed:inout Int) -> Rectangle<Int>?
    {
        
    }

    enum Periphery 
    {
        case white(Int), gray(Int), flush
        
        mutating 
        func collapse(_ next:Self) -> Int 
        {
            switch (self, next) 
            {
            case    (_, .begin(.white(0))), 
                    (_, .begin(.gray (0))), 
                    (_, .end  (.white(0))), 
                    (_, .end  (.gray (0))):
                return 0 
            
            case    (.begin(.white(let width)), .begin(.white(let margin))), 
                    (.end  (.white(let width)), .begin(.white(let margin))):
                self = .begin(.white(max(margin,  width)))
                return max(0,            margin - width)
            
            case    (.end  (.white(let width)), .end  (.white(let margin))):
                self = .end  (.white(max(margin,  width)))
                return max(0,            margin - width)
            
            case    (.begin(.gray (let width)), .begin(.gray (let border))), 
                    (.end(  .gray (let width)), .begin(.gray (let border))):
                self = .begin(.gray (max(border,  width)))
                return max(0,            border - width)
            
            case    (.end(  .gray (let width)), .end(  .gray (let border))):
                self = .end(  .gray (max(border, width)))
                return max(0,            border - width)
            
            case    (_, .begin(.white(let width))), 
                    (_, .begin(.gray (let width))), 
                    (_, .end  (.white(let width))), 
                    (_, .end  (.gray (let width))):
                self = next 
                return width
            
            case    (_, .flush):
                self = .flush 
                return 0
            }
        }
        
        mutating 
        func flush(_ width:Int) -> Int 
        {
            self = .flush 
            return width
        }
    }
    
    func constrain(
        begin:(periphery:Periphery, keyPath:KeyPath<Metrics, Int>), 
        end:(periphery:Periphery, keyPath:KeyPath<Metrics, Int>), 
        parallel:KeyPath<Vector2<Int>, Int>) 
        -> (constraints:[(index:Int?, offset:Int, min:Int, claims:Int)], reserved:Int)
    {
        var constraints:[(index:Int?, offset:Int, min:Int, claims:Int)] = []
        
        var reserved:Int        = 0
        var periphery:Periphery = begin.periphery
        
        reserved += periphery.collapse(.white(self.computed.margin[keyPath: begin.keyPath]))
        reserved += periphery.collapse(.gray (self.computed.border[keyPath: begin.keyPath]))
        
        let (min, claim):(Vector2<Int>, Vector2<Int>) = self.claim() 
        constraints.append((nil, reserved, min[keyPath: axis], claim[keyPath: axis]))
        
        if min[keyPath: axis] > 0 || claims[keyPath: axis] > 0 
        {
            reserved += periphery.flush(min[keyPath: axis])
        }
        
        for child:Int in 0 ..< self.count where self[child] is UI.Element.Block
        {
            reserved += periphery.collapse(.white(self[child].computed.margin.left))
            reserved += periphery.collapse(.gray (self[child].computed.border.left))
            
            let (min, claim):(Vector2<Int>, Vector2<Int>) = self[child].claim() 
            constraints.append((child, reserved, min[keyPath: axis], claim[keyPath: axis]))
            reserved += periphery.flush(min[keyPath: axis])
            
            reserved += periphery.collapse(.gray (self[child].computed.border.right))
            reserved += periphery.collapse(.white(self[child].computed.margin.right))
        }
        
        reserved += periphery.collapse(.gray (self.computed.border.right))
        reserved += periphery.collapse(.white(self.computed.margin.right))
        
        reserved += periphery.collapse(right)
        
        return (constraints, reverved)
    }
    
    func fit(in rectangle:Rectangle<Int>, 
        top:Periphery, right:Periphery, bottom:Periphery, left:Periphery) 
        -> Vector2<Int>
    {
        switch self.cache.computed.axis
        {
        case .horizontal:
            var claims:[(Claim)] = []
            // figure out how much space we need to reserve for borders/margins
            
            
            var totalClaims:Int = 0
            for claim:Claim in claims 
            {
                switch claim 
                {
                case .fixed(width: let width):
                    reserved    += width 
                case .claim(minWidth: let minWidth, claims: let claims):
                    reserved    += minWidth 
                    totalClaims += claims 
                }
            }
            
            let flex:Int = max(0, rectangle.size.x - reserved)
            
        case .vertical:
            break
        }
    }
} */
extension UI.Element.Block 
{
    enum Layout 
    {
        struct Constraints
        {
            let min:Vector2<Int>
            let grow:Int
            
            // child stats
            let offsets:[Vector2<Int>]
        }
        
        typealias Soft    = (style:UI.Style.Rules, constraints:Constraints)
        typealias Hard    = Vector2<Int> // canvas size
        typealias Content = Vector2<Int> // occupied size (can be larger than canvas)
        
        var soft:Soft 
        var hard:Hard
        var content:Content
        
        init() 
        {
            self.soft    = (.init(), .init(min: .zero, grow: 0, offsets: []))
            self.hard    = .zero 
            self.content = .zero
        }
    }
    
    private 
    enum Periphery 
    {
        case white(Int), gray(Int), flush
        
        init(style:UI.Style.Rules, metric:KeyPath<Metrics, Int>) 
        {
            let gray:Int = self.computed.border[keyPath: metric]
            if gray == 0 
            {
                let white:Int = self.computed.margin[keyPath: metric]
                if white == 0 
                {
                    self = .flush 
                }
                else 
                {
                    self = .white(white)
                }
            }
            else 
            {
                self = .gray(gray) 
            }
        }
        
        mutating 
        func collapse(_ next:Self) -> Int 
        {
            switch (self, next) 
            {
            case    (_, .begin(.white(0))), 
                    (_, .begin(.gray (0))), 
                    (_, .end  (.white(0))), 
                    (_, .end  (.gray (0))):
                return 0 
            
            case    (.begin(.white(let width)), .begin(.white(let margin))), 
                    (.end  (.white(let width)), .begin(.white(let margin))):
                self = .begin(.white(max(margin,  width)))
                return max(0,            margin - width)
            
            case    (.end  (.white(let width)), .end  (.white(let margin))):
                self = .end  (.white(max(margin,  width)))
                return max(0,            margin - width)
            
            case    (.begin(.gray (let width)), .begin(.gray (let border))), 
                    (.end(  .gray (let width)), .begin(.gray (let border))):
                self = .begin(.gray (max(border,  width)))
                return max(0,            border - width)
            
            case    (.end(  .gray (let width)), .end(  .gray (let border))):
                self = .end(  .gray (max(border, width)))
                return max(0,            border - width)
            
            case    (_, .begin(.white(let width))), 
                    (_, .begin(.gray (let width))), 
                    (_, .end  (.white(let width))), 
                    (_, .end  (.gray (let width))):
                self = next 
                return width
            
            case    (_, .flush):
                self = .flush 
                return 0
            }
        }
        
        mutating 
        func flush(_ width:Int) -> Int 
        {
            if width > 0 
            {
                self = .flush 
            }
            return width
        }
    }
    
    mutating 
    func invalidate(recursive flag:KeyPath<Cache.Status, Bool>) 
    {
        self.cache.recompute[keyPath: flag] = true 
        for c:Int in 0 ..< self.count 
        {
            self[c].invalidate(recursive: flag)
        }
    }
    
    mutating 
    func invalidate(propogate flag:KeyPath<Cache.Status, Bool>) 
    {
        for child:UI.Element.Block in self  
        {
            if child.cache.recompute[keyPath: flag] 
            {
                self.cache.recompute[keyPath: flag] = true 
                return 
            }
        }
    }
    
    mutating 
    func layoutSoft(definitions:inout UI.Styles, ancestry:UI.Style.Path) -> Bool 
    {
        var recompute:Bool = false
        let path:Style.Path   = ancestry.appended(self)
        self.layoutBefore(definitions: &definitions, path: path)
        if self.recomputeStyle 
        {
            let style:Style.Rules = definitions.resolve(path).overlaid(with: self.style) 
            
            if  style.margin  != self.cache.soft.style.margin   ||
                style.border  != self.cache.soft.style.border   ||
                style.padding != self.cache.soft.style.padding  ||
                style.axis    != self.cache.soft.style.axis     ||
                style.grow    != self.cache.soft.style.grow 
            {
                recompute = true  
            }
            
            // custom observers 
            self.observe(style: style)
            
            self.cache.soft.style = style 
        }
        
        // update soft layouts for children 
        for c:Int in self.indices
        {
            // check if any of the children’s soft layouts changed, and propogate 
            // the flag back to the parent (self)
            recompute = self[c].layoutSoft(definitions: &definitions, ancestry: path) || recompute
        }
        
        guard recompute
        else 
        {
            return false 
        }
        
        // compute own soft layout 
        let axis:Axis = self.cache.soft.style.axis
        var main:(begin:Periphery, end:Periphery)  = 
        (
            .init(style: self.cache.soft.style, metric: axis.main.metric.0), 
            .init(style: self.cache.soft.style, metric: axis.main.metric.1)
        )
        let cross:(begin:Periphery, end:Periphery) = 
        (
            .init(style: self.cache.soft.style, metric: axis.cross.metric.0), 
            .init(style: self.cache.soft.style, metric: axis.cross.metric.1)
        )
        
        var offset:(main:Int, cross:Int) = .zero, 
            offsets:[Vector2<Int>]       = []
        var minCross:Int                 = 0
        
        offset.main  += main.begin.flush(self.cache.soft.style.padding[keyPath: axis.main.metric.0])
        
        if let leaf:Vector2<Int> = self.layoutLeaf() 
        {
            offset.main  += main.begin.flush(leaf[keyPath: axis.main.component])
            
            var localCross:Periphery = cross.begin
            offset.cross += localCross.flush(leaf[keyPath: axis.cross.component])
            offset.cross += localCross.collapse(cross.end)
            minCross      = max(minCross, offset.cross)
        }
        
        for soft:Layout.Soft in self.map{ $0.cache.soft }
        {
            // leading edge 
            offset.main  += main.begin.collapse(.white(soft.style.margin[keyPath: axis.main.metric.0]))
            offset.main  += main.begin.collapse( .gray(soft.style.border[keyPath: axis.main.metric.0]))
            
            var localCross:Periphery = cross.begin
            offset.cross  = localCross.collapse(.white(soft.style.margin[keyPath: axis.cross.metric.0]))
            offset.cross += localCross.collapse( .gray(soft.style.border[keyPath: axis.cross.metric.0]))
            
            // kernel 
            let vector:Vector2<Int> = directReturn(.zero) 
            {
                $0[keyPath: axis.main.component]  = offset.main
                $0[keyPath: axis.cross.component] = offset.cross
            }
            offsets.append(vector)
            
            offset.main  += soft.constraints.min[keyPath: axis.main.component]
            offset.cross += soft.constraints.min[keyPath: axis.cross.component]
            
            // trailing edge
            offset.main  += main.begin.collapse( .gray(soft.style.border[keyPath: axis.main.metric.1]))
            offset.main  += main.begin.collapse(.white(soft.style.margin[keyPath: axis.main.metric.1]))
            
            offset.cross += localCross.collapse( .gray(soft.style.border[keyPath: axis.cross.metric.1]))
            offset.cross  = localCross.collapse(.white(soft.style.margin[keyPath: axis.cross.metric.1]))
            
            // outer trailing cross-edge
            offset.cross += localCross.collapse(cross.end)
            minCross = max(minCross, offset.cross)
        } 
        
        // outer trailing main-edge 
        offset.main  += main.begin.flush(self.cache.soft.style.padding[keyPath: axis.main.metric.1])
        offset.main  += main.begin.collapse(main.end)
        
        let min:Vector2<Int> = directReturn(.zero) 
        {
            $0[keyPath: axis.main.component]  = offset.main
            $0[keyPath: axis.cross.component] = minCross
        }
        
        self.cache.soft.constraints = .init(min: min, grow: style.grow, offsets: offsets)
        return true 
    }
    
    mutating 
    func layoutHard(in canvas:Vector2<Int>) 
    {
        guard canvas != self.cache.hard
        else 
        {
            return 
        }
        
        self.observe(canvas: canvas)
        self.cache.hard = canvas
        
        let axis:Axis = self.cache.soft.style.axis, 
            constraints:Constraints = self.cache.soft.constraints
        
        let available:Vector2<Double> = .init(
            max(0, canvas.x - constraints.min.x), 
            max(0, canvas.y - constraints.min.y))
        // add up total claims 
        let claims:Double  = max(1, .init(self.reduce(0){ $0 + $1.cache.soft.constraints.grow }))
        var claimed:Double = 0
        // update hard layouts for children 
        for (c, offset):(Int, Vector2<Int>) in zip(self.indices, self.cache.soft.offsets)
        {
            let childConstraints:Constraints = self[c].cache.soft.constraints
            let include:Double = claimed + .init(childConstraints.grow)
            defer 
            {
                claimed = include 
            }
            let flex:(Vector2<Double>, Vector2<Double>) = 
            (
                claimed / claims * available, 
                include / claims * available
            )
            
            let a:Vector2<Int> = .cast(.cast(offset) + flex.0), 
                b:Vector2<Int> = .cast(.cast(offset) + .cast(childConstraints.min) + flex.1)
            
            self[c].layoutHard(in: a &- b)
        }
    }
    
    mutating 
    func layoutContent() 
    {
        var content:Vector2<Int> = .zero
        if let leaf:Vector2<Int> = self.layoutLeafContent() 
        {
            content &+= leaf
        }
        for c:Int in self.indices 
        {
            self[c].layoutContent()
            content &+= self[c].cache.content &- self[c].cache.soft.constraints.min 
        }
        
        self.cache.content = content &+ self.cache.soft.constraints.min
    }
}

extension UI 
{
    typealias Element = _UIElement
    
    enum Geometry
    {
        struct DrawElement:RandomAccessCollection
        {
            struct Point 
            {
                var s:Vector2<Float>, // screen coordinates (pixels)
                    color:Vector4<UInt8>
            }
            typealias Triangle = (Int, Int, Int)
            
            struct Vertex:GPU.Vertex.Structured
            {
                // screen coordinates (pixels)
                let s:(Float, Float) 
                // padding 
                let p:(Float, Float) = (0, 0)
                // tracer coordinates
                var r:(Float, Float, Float)
                // color coordinates
                var c:(UInt8, UInt8, UInt8, UInt8)
                
                static 
                let attributes:[GPU.Vertex.Attribute<Self>] =
                [
                    .float32x2(\.s, as: .float32),
                    .float32x3(\.r, as: .float32),
                    .uint8x4(  \.c, as: .float32(normalized: true))
                ]
            }
            
            // 3D tracing is disabled using a (.nan, .nan, .nan) triple
            private(set)
            var points:[Point]
            let triangles:[Triangle]
            var s0:Vector2<Float>, 
                r0:Vector3<Float> 
            
            var startIndex:Int 
            {
                return self.points.startIndex 
            }
            var endIndex:Int 
            {
                return self.points.endIndex 
            }
            
            subscript(index:Int) -> Vertex
            {
                let p:Point = self.points[index]
                return .init(
                    s: (self.s0 + p.s).tuple, 
                    r: self.r0.tuple, 
                    c: p.color.tuple)
            }
            
            mutating 
            func color(_ range:Range<Int>, _ color:Vector4<UInt8>) 
            {
                for i:Int in range.clamped(to: self.points.indices) 
                {
                    self.points[i].color = color
                }
            }
            
            func offsetted(by offset:Vector2<Float>) -> Self 
            {
                return 
                    .init(
                        points:     self.points, 
                        triangles:  self.triangles, 
                        s0:         self.s0 + offset, 
                        r0:         self.r0
                    )
            }
        }
    }
    
    struct Text:Element.Block
    {
        struct DrawElement:RandomAccessCollection
        {
            struct Glyph 
            {
                var s:Rectangle<Float>, // screen coordinates (pixels)
                    t:Rectangle<Float>, // texture coordinates 
                    color:Vector4<UInt8>
            }
            
            struct Vertex:GPU.Vertex.Structured
            {
                // screen coordinates (pixels)
                let s:(Float, Float) 
                // texture coordinates 
                let t:(Float, Float)
                // tracer coordinates
                var r:(Float, Float, Float)
                // color coordinates
                var c:(UInt8, UInt8, UInt8, UInt8)
                
                static 
                let attributes:[GPU.Vertex.Attribute<Self>] =
                [
                    .float32x2(\.s, as: .float32),
                    .float32x2(\.t, as: .float32),
                    .float32x3(\.r, as: .float32),
                    .uint8x4(  \.c, as: .float32(normalized: true))
                ]
            }
            
            // 3D tracing is disabled using a (.nan, .nan, .nan) triple
            private(set)
            var glyphs:[Glyph]
            var s0:Vector2<Float>, 
                r0:Vector3<Float> 
            
            var startIndex:Int 
            {
                return self.glyphs.startIndex 
            }
            var endIndex:Int 
            {
                return self.glyphs.endIndex 
            }
            
            init(glyphs:[Glyph], s0:Vector2<Float>, r0:Vector3<Float>) 
            {
                self.glyphs    = glyphs 
                self.s0 = s0 
                self.r0 = r0
            }
            
            private 
            func vertex(s:Vector2<Float>, t:Vector2<Float>, color:Vector4<UInt8>) -> Vertex 
            {
                return .init(
                    s: s.tuple, 
                    t: t.tuple, 
                    r: self.r0.tuple, 
                    c: color.tuple)
            }
            
            subscript(index:Int) -> (Vertex, Vertex) 
            {
                let g:Glyph = self.glyphs[index]
                return 
                    (
                        self.vertex(s: g.s.a + self.s0, t: g.t.a, color: g.color), 
                        self.vertex(s: g.s.b + self.s0, t: g.t.b, color: g.color)
                    )
            }
            
            mutating 
            func color(_ range:Range<Int>, _ color:Vector4<UInt8>) 
            {
                for i:Int in range.clamped(to: self.glyphs.indices) 
                {
                    self.glyphs[i].color = color
                }
            }
            
            func offsetted(by offset:Vector2<Float>) -> Self 
            {
                return 
                    .init(
                        glyphs: self.glyphs, 
                        s0:     self.s0 + offset, 
                        r0:     self.r0
                    )
            }
        }
        
        struct Run:Element
        {
            let classes:Set<String>, 
                identifier:String?
            
            var text:String, 
                style:Style.Rules 
            
            init(_ text:String, classes:Set<String> = [], identifier:String? = nil, 
                style:Style.Rules = .init()) 
            {
                self.text       = text 
                self.classes    = classes 
                self.identifier = identifier 
                self.style      = style 
            }
        }
        
        private 
        enum Cache 
        {
            struct Content 
            {
                var draw:DrawElement, 
                    ranges:[Range<Int>]
                
                var size:Vector2<Int>
            }
            
            case invalid
            case semivalid(Content)
            case valid(Content)
            
            mutating 
            func invalidate() 
            {
                self = .invalid 
            }
            
            mutating 
            func semiinvalidate() 
            {
                switch self 
                {
                case .invalid, .semivalid:
                    break 
                case .valid(let cache):
                    self = .semivalid(cache)
                }
            }
        }
        
        let classes:Set<String>, 
            identifier:String?
        
        var cache:Element.Block.Layout
        
        private 
        var runs:[Run]
        var style:Style.Rules            
        private 
        var _cache:Cache
        
        private 
        var description:String 
        {
            "UI.Text{\(self.runs.map{ $0.run.text }.joined(separator: ""))}"
        }
        
        init(_ runs:[Run], classes:Set<String> = [], identifier:String? = nil, 
            style:Style.Rules = .init()) 
        {
            self.runs       = runs.map{ ($0, nil) }
            self.classes    = classes 
            self.identifier = identifier 
            self.style      = style 
            
            self._cache     = .invalid 
            self.cache      = .init()
        }
        
        // UIElement conformance 
        func contribute(text:inout [Self.DrawElement], offset:Vector2<Float>) 
        {
            switch self.cache 
            {
            case .valid(let cache):
                text.append(cache.draw.offsetted(by: offset))
            case .semivalid(let cache):
                text.append(cache.draw.offsetted(by: offset))
                Log.warning("text element \(self.description) was drawn with semivalid cache")
            case .invalid:
                Log.error("text element \(self.description) could not be drawn (invalid cache)")
            }
        }
        func contribute(geometry:inout [Geometry.DrawElement], offset:Vector2<Float>) 
        {
            
            switch self.cache 
            {
            case .invalid:
                Log.error("text element \(self.description) could not be drawn (invalid cache)")
            case .semivalid(let cache):
                Log.warning("text element \(self.description) was drawn with semivalid cache")
                fallthrough 
            case .valid(let cache):
                let draw:Geometry.DrawElement = .init(points: 
                    [
                        .init(s: .init(0, 0),                   color: .init(0, 0, 0, .max)), 
                        .init(s: .init(.init(cache.size.x), 0), color: .init(255, 0, 255, .max)), 
                        .init(s: .cast(cache.size),             color: .init(255, 0, 255, .max)), 
                        .init(s: .init(0, .init(cache.size.y)), color: .init(0, 0, 0, .max)), 
                    ], 
                    triangles: [(0, 3, 2), (0, 2, 1)],
                    s0: .init(10, 50), 
                    r0: .init(.nan, .nan, .nan))
                geometry.append(draw.offsetted(by: offset))
            }
        }
        
        mutating 
        func event(_ event:UI.Event, pass _:UI.Event.Pass) 
        {
            switch event 
            {
            case .character(let character):
                self[1].text.append(character)
            
            case .paste(let string):
                self[1].text += string
            default:
                return 
            }
        }
        
        mutating 
        func process(delta _:Int, allotment:Vector2<Int>) -> Bool 
        {
            self.allotment = allotment
            
            if case .valid = self.cache 
            {
                return false 
            }
            else 
            {
                return true 
            }
        }
        
        
        func layoutBefore(definitions:inout UI.Styles, path:UI.Style.Path)  
        {
        }
        func layoutLeaf() -> Vector2<Int>? 
        {
            return nil 
        }
        func layoutLeafContent() -> Vector2<Int>
        {
            return .zero
        }
        func observe(style _:UI.Style.Rules) 
        {
            self.cache.invalidate()
        }
        func observe(canvas _:Vector2<Int>)
        {
        }
        
        mutating 
        func layout(styledefs:inout Style, path:Style.Path) -> Vector2<Int>
        {
            let path:Style.Path = path.appended(self)
            // check block styles 
            let lookup:(sequence:UInt, style:Style.Rules) = styledefs.resolve(path)
            if (self.sequence.map{ $0 != lookup.sequence }) ?? true 
            {
                self.cache.invalidate()
                self.sequence = lookup.sequence
            }
            
            let style:Style.Rules    = lookup.style.overlaid(with: self._style)
            var styles:[Style.Rules] = []
                styles.reserveCapacity(self.runs.count)
            // compute styling for inline runs 
            for i:Int in self.runs.indices
            {
                // check inline styles
                let lookup:(sequence:UInt, style:Style.Rules) = 
                    styledefs.resolve(path.appended(self[i]))
                if (self.runs[i].sequence.map{ $0 != lookup.sequence }) ?? true
                {
                    self.cache.invalidate()
                    self.runs[i].sequence = lookup.sequence
                }
                
                styles.append(lookup.style.overlaid(with: self[i].style))
            }
            
            switch self.cache 
            {
            case .valid(let cache):
                return cache.size 
            
            case .semivalid(var cache):
                cache.draw.s0 = style.offset
                cache.draw.r0 = style.trace 
                for (runstyle, range):(Style.Rules, Range<Int>) in zip(styles, cache.ranges) 
                {
                    cache.draw.color(range, runstyle.color)
                }
                
                self.cache = .valid(cache)
                return cache.size
            
            case .invalid:
                let texts:[String]      = self.runs.map{ $0.run.text }
                let cache:Cache.Content = Self.reshape((texts, styles), 
                    style: style, allotment: self.allotment, styledefs: &styledefs)
                
                self.cache = .valid(cache)
                return cache.size
            }
        }
        
        private static  
        func reshape(_ runs:(texts:[String], styles:[Style.Rules]), style:Style.Rules, 
            allotment:Vector2<Int>, styledefs:inout Style)
            -> Cache.Content
        {
            // fill in shaping parameters 
            let parameters:[HarfBuzz.ShapingParameters] = runs.styles.map 
            {
                let parameters:HarfBuzz.ShapingParameters = 
                    .init(
                        font: styledefs.font($0.font), 
                        features: $0.features.map{ ($0.tag, .init($0.value)) }
                    )
                return parameters
            }
            
            var stc:[DrawElement.Glyph] = []
            let ranges:[Range<Int>], 
                size:Vector2<Int>
            if style.wrap
            {
                // no concept of 2D grid layout, new lines just reset the x coordinate to 0 (or indent)
                let (glyphs, indices):([HarfBuzz.Glyph], (runs:[Range<Int>], lines:[Range<Int>])) = 
                    HarfBuzz.paragraph(zip(runs.texts, parameters), indent: style.indent, width: allotment.x << 6)
                ranges = indices.runs 
                stc.reserveCapacity(glyphs.count)
                // line number, should start at 0
                var l:Int = indices.lines.startIndex
                for ((runstyle, parameters), range):((Style.Rules, HarfBuzz.ShapingParameters), Range<Int>) in 
                    zip(zip(runs.styles, parameters), indices.runs) 
                {
                    for (i, g):(Int, HarfBuzz.Glyph) in zip(range, glyphs[range])
                    {
                        while !(indices.lines[l] ~= i) 
                        {
                            l += 1
                        }
                        
                        let sort:Typeface.Font.SortInfo = parameters.font.sorts[g.index]
                        // convert 64-point fractional units to ints to floats 
                        let p:Vector2<Int> = g.position &+ .init(0, (l + 1) * style.line_height) &<< 6, 
                            a:Vector2<Int> = sort.vertices.a &+ p, 
                            b:Vector2<Int> = sort.vertices.b &+ p
                        
                        let s:Rectangle<Float> = .init(.cast(a &>> 6), .cast(b &>> 6))
                        stc.append(.init(s: s, t: styledefs.atlas[sort.sprite], color: runstyle.color))
                    }
                }
                
                size = .init(allotment.x, indices.lines.count * style.line_height)
            }
            else 
            {
                let glyphs:[HarfBuzz.Glyph], 
                    width:Int 
                (glyphs, ranges, width) = HarfBuzz.line(zip(runs.texts, parameters))
                stc.reserveCapacity(glyphs.count)
                
                for ((runstyle, parameters), range):((Style.Rules, HarfBuzz.ShapingParameters), Range<Int>) in 
                    zip(zip(runs.styles, parameters), ranges) 
                {
                    for g:HarfBuzz.Glyph in glyphs[range]
                    {
                        let sort:Typeface.Font.SortInfo = parameters.font.sorts[g.index]
                        let s:Rectangle<Float> = .init(
                            .cast((sort.vertices.a &+ g.position) &>> 6), 
                            .cast((sort.vertices.b &+ g.position) &>> 6)
                        )
                        
                        stc.append(.init(s: s, t: styledefs.atlas[sort.sprite], color: runstyle.color))
                    }
                }
                
                size = .init(width, style.line_height)
            }
            
            let draw:DrawElement = .init(glyphs: stc, s0: style.offset, r0: style.trace)
            
            return .init(draw: draw, ranges: ranges, size: size)
        }
    }
    
    enum Layout 
    {
        /* enum HorizontalBox<Child> where Child:Element
        {
            private 
            enum Cache 
            {
                case invalid  
                case valid(size:Vector2<Int>)
                
                mutating 
                func invalidate() 
                {
                    self = .invalid 
                }
            }
            
            var style:Style.Rules.Block
            {
                willSet(style)
                {
                    if style.padding != self.style.padding 
                    {
                        self.cache.invalidate()
                    }
                }
            }
            
            private 
            var allotment:Vector2<Int>
            {
                willSet(allotment)
                {
                    if allotment != self.allotment  
                    {
                        self.cache.invalidate()
                    }
                }
            }
            
            func contribute(text:inout [UI.Text.DrawElement], offset:Vector2<Float>) 
            {
                self.child.contribute(text: &text, offset: self.offset)
            }
            func contribute(geometry _:inout [UI.Geometry.DrawElement], offset _:Vector2<Float>)
            {
                self.child.contribute(geometry: &geometry, offset: self.offset)
            }
            
            mutating 
            func event(_ event:UI.Event, pass:UI.Event.Pass) 
            {
                self.child.event(event, pass: pass)
            }
            
            mutating 
            func navigate(_ direction:UI.Event.Direction.D2) -> Bool 
            {
                return self.child.navigate(direction)
            }
            
            mutating 
            func process(delta _:Int, allotment:Vector2<Int>) -> Bool 
            {
                self.allotment = allotment
                
                if case .valid = self.cache 
                {
                    return false 
                }
                else 
                {
                    return true 
                }
            }
            
            func layout(allotment _:Vector2<Int>, styledefs _:inout UI.Style) -> Vector2<Int> 
            {
                return .zero 
            }
        } */
    }
    
    /*
    struct VerticalList:UIElement
    {
        private 
        var children:[UIElement], 
            offsets:[Int]
        
        private 
        var allotment:Vector2<Int>, 
            size:Vector2<Int>
        
        // UIElement conformance 
        var focused:Bool 
        {
            return !self.children.allSatisfy{ !$0.focused }
        }
        
        func contribute(text:inout [Text.DrawElement], offset:Vector2<Float>) 
        {
            for (child, y):(UIElement, Int) in zip(self.children, self.offsets)
            { 
                text.contribute(&text, offset: offset + .cast(0, y))
            }
        }
        func contribute(geometry:inout [Text.DrawElement], offset:Vector2<Float>) 
        {
            for (child, y):(UIElement, Int) in zip(self.children, self.offsets)
            { 
                geometry.contribute(&text, offset: offset + .cast(0, y))
            }
        }
        
        init(_ children:[UIElement] = [])
        {
            self.children  = children
            self.offsets   = .init(repeating: 0, count: children.count)
            self.allotment = .zero 
        }
        
        mutating 
        func keypress(_ key:UI.Key, _ modifiers:UI.Key.Modifiers) -> [Response]
        {
            var responses:[Response] = []
            for i:Int in self.children.indices where self.children[i].focused 
            {
                responses.append(contentsOf: self.children[i].keypress(key, modifiers))
            }
            return responses
        }
        mutating 
        func character(_ character:Character) -> [Response]
        {
            var responses:[Response] = []
            for i:Int in self.children.indices where self.children[i].focused 
            {
                responses.append(contentsOf: self.children[i].character(character))
            }
            return responses
        }
        
        mutating 
        func leave() -> [Response]
        {
            var responses:[Response] = []
            for i:Int in self.children.indices where self.children[i].focused 
            {
                responses.append(contentsOf: self.children[i].leave())
            }
            return responses
        }
        mutating 
        func next() -> ([UI.Response], Bool)
        {
            var responses:[Response] = []
            for i:Int in self.children.indices where self.children[i].focused 
            {
                let next:(responses:[UI.Response], empty:Bool) = self.children[i].next()
                responses.append(contentsOf: next.responses)
                
                // defocus all other children 
                for j:Int in (i + 1) ..< self.children.endIndex where self.children[j].focused 
                {
                    responses.append(contentsOf: self.children[j].leave())
                }
                
                if next.empty 
                {
                    for j:Int in (i + 1) ..< self.children.endIndex 
                    {
                        responses.append(contentsOf: self.children[j].enter())
                        if self.children[j].focused 
                        {
                            return (responses, false)
                        }
                    }
                    
                    break 
                }
                else 
                {
                    return (responses, false)
                }
            }
            
            return (responses, true)
        }
        mutating 
        func enter() -> [Response] 
        {
            if self.children.isEmpty 
            {
                return []
            }
            else 
            {
                return self.children[self.children.startIndex].enter()
            }
        }
        
        func process(model:Model, delta:Int) -> Bool 
        {
            var mutated:Bool = false 
            for i:Int in self.children.indices 
            {
                mutated = self.children[i].process(model: model, delta: delta) || mutated 
            }
            return mutated 
        }
        
        mutating 
        func layout(allotment:Vector2<Int>) -> Vector2<Int>
        {
            guard allotment != self.allotment 
            else 
            {
                return self.size 
            }
            
            self.allotment = allotment 
            
            self.size = .zero            
            for i:Int in self.children.indices 
            {
                self.offsets[i] = bb.y
                
                let allotment:Vector2<Int>  = .init(allotment.x, allotment.y - bb.y), 
                    size:Vector2<Int>       = self.children[i].layout(allotment: allotment)
                
                self.size.x  = max(self.size.x, size.x)
                self.size.y += size.y
            }
            
            return self.size
        }
    }
    
    struct Label:UIElement 
    {
        private 
        var allotment:Vector2<Int>, 
            size:Vector2<Int>
            
        private 
        var text:[(Style.Inline, String)], 
            style:Style.Block 
        
        // cache 
        private 
        var glyphs:[(glyph:Text.Glyph, color:Vector4<UInt8>)], 
            runs:[Range<Int>]
        
        var fixedText:[Text.Vertex] 
        {
            return []
        } 

        mutating 
        func push(text:[(Style.Inline, String)], style:Style.Block)
        {
            let linebox:Vector2<Int> = .init()
        }
        
        mutating 
        func size(available:Vector2<Int>) -> Vector2<Int>
    }
    
    struct Console 
    {
        private 
        var cells:[(history:String, field:[Character])], 
            arrow:Int
        
        private(set)
        var hash:UInt64 = 0
        
        private(set)
        var cursors:Range<Int>
        {
            didSet 
            {
                self.hash &+= 1
            }
        }
        
        private(set)
        var field:[Character] 
        {
            get 
            {
                return self.cells[self.arrow].field
            }
            set(v) 
            {
                self.cells[self.arrow].field = v
                self.hash &+= 1
            }
        }
        
        init() 
        {
            self.cells = [(history: "", field: [])]
            self.arrow = self.cells.endIndex - 1
            
            self.cursors = 0 ..< 0
        }
        
        mutating 
        func keypress(_ key:UI.Key, _ modifiers:UI.Key.Modifiers) -> [Response]
        {
            switch key 
            {
            case .enter:
                let command:String = .init(self.field)
                self.cells[self.cells.endIndex - 1] = (command, self.field)
                self.cells.append(("", []))
                self.field   = .init(self.cells[self.arrow].history)
                self.arrow   = self.cells.endIndex - 1
                self.cursors = 0 ..< 0
                
                Log.note(command)
                return [.text(command)]
            
            case .up:
                if self.arrow > self.cells.startIndex 
                {
                    self.arrow  -= 1
                    self.cursors = self.field.endIndex ..< self.field.endIndex
                }
            
            case .down:
                if self.arrow < self.cells.endIndex - 1 
                {
                    self.arrow  += 1
                    self.cursors = self.field.endIndex ..< self.field.endIndex
                }
            
            case .left:
                let i:Int 
                if modifiers.control 
                {
                    i    = self.field[..<self.cursors.lowerBound].lastIndex{ $0 != " " } 
                        ?? self.field.startIndex
                }
                else 
                {
                    i    = max(self.cursors.lowerBound - 1, self.field.startIndex)
                }
                
                self.cursors = i ..< (modifiers.shift ? self.cursors.upperBound : i)
            
            case .right:
                let j:Int 
                if modifiers.control 
                {
                    j    = self.field[self.cursors.upperBound...].firstIndex{ $0 != " " } 
                        ?? self.field.endIndex
                }
                else 
                {
                    j    = min(self.cursors.upperBound + 1, self.field.endIndex)
                }
                
                self.cursors = (modifiers.shift ? self.cursors.lowerBound : j) ..< j
            
            case .backspace:
                if self.cursors.count == 0 
                {
                    self.keypress(.left, modifiers | .init(shift: true))
                }
                
                self.field.removeSubrange(self.cursors)
            
            case .delete:
                if self.cursors.count == 0 
                {
                    self.keypress(.right, modifiers | .init(shift: true))
                }
                
                self.field.removeSubrange(self.cursors)
            
            default:
                break 
            }
            
            return []
        }
        
        mutating 
        func character(_ character:Character) -> [Response]
        {
            Log.note("\(character)")
            self.field[self.cursors] = [character]
            self.cursors = self.cursors.lowerBound + 1 ..< self.cursors.upperBound + 1
            
            return [] 
        }
    }
    */
}
